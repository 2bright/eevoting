pragma solidity ^0.4.24;

import './Usergroup.sol';

library Voting {
  using Usergroup for Usergroup.Manager;

  struct Manager {
    mapping(address => uint32[]) votingsIPublished;
    mapping(address => uint32[]) votingsIVoted;
    mapping(address => uint32[]) votingsIWatching;
    mapping(address => uint32[]) votingsInUsergroup;

    uint32[] votingsInPublic;

    mapping(address => PublishingRecord) votingIPublishing;

    uint32[] votingsNone;

    Record[] votings;
  }

  struct PublishingRecord {
    // an incremental variable for each account, used to identify current publishing voting.
    uint32 nonce;

    // an random variable generated by client, used to identify current publishing voting.
    uint32 client_nonce;

    // total number of slices
    uint32 slices_num;

    // votings[voting_id].create_time == 0 means publishing
    uint32 voting_id;

    // got_slices.length is equal to slices_num. when got a slice set corresponding byte to 1.
    bytes got_slices;
  }
  
  struct Record {
    // content of a voting is description and options etc.
    // content can be large if image or file is included, so slice strategy is applied. length of a slice better be multiple of 32 bytes.
    // content can be the digest of voting content, e.g. a hash value and title, the complete content could be stored at other server.
    bytes[] content;

    Params params;
    Result result;

    // all votes
    // index 0 store no vote
    Vote[] votes;

    // map from voter address to vote index
    mapping(address => uint32) votes_index;
  }

  struct Params {
    // extract title from content is for pagination query votings.
    bytes title;

    // usergroup_id as 0 means public voting
    uint32 usergroup_id;

    // number of options
    uint32 options_num;

    // how many options could one voter select.
    uint32 select_min;
    uint32 select_max;

    // allow voting when time is in [start_time, end_time]
    uint32 start_time;
    uint32 end_time;

    // If allow_multi_winner is false but has multiple winners, then result is no winner.
    uint32 allow_multi_winner;

    // if total votes count is less than min_total_votes, voting has no winner.
    // n is numerator, d is denominator.
    // if denominator is 1, then min_total_votes is count of votes, else min_total_votes is radio of total votes to number of usergroup members.
    uint32 n_min_total_votes;
    uint32 d_min_total_votes;

    // if a winner has votes count less than min_winner_votes, voting has no winner.
    // n is numerator, d is denominator.
    // if denominator is 1, then min_winner_votes is count of votes, else min_winner_votes is radio of winner votes to total votes.
    uint32 n_min_winner_votes;
    uint32 d_min_winner_votes;

    // the time publish this voting
    uint32 create_time;

    // index of voting in Manager.votings
    uint32 id;

    // number of voters in usergroup
    uint32 voters_max;

    // max number of votes, if voters have weight, then votes_max is not equal to voters_num.
    uint32 votes_max;

    // who publish this voting
    address owner;
  }

  struct Vote {
    address voter;

    // selected option indexes.
    uint32[] options;

    // vote time
    uint32 vote_time;
  }

  struct Result {
    // number of votes for each option
    uint32[] options;

    // total number of voters
    uint32 voters_num;

    // total number of votes
    uint32 votes_num;
  }

  enum VotingCategory {IPublished, IVoted, IWatching, InPublic, InUsergroup}

  event PublishVoting(uint32 nonce, uint32 client_nonce, uint32 id, bytes title);

  function getVotingNonce(Manager storage self) public view returns(uint32 _nonce) {
    return self.votingIPublishing[msg.sender].nonce + 1;
  }

  function parseParams(bytes32[2] _params, bytes _title, Usergroup.Manager storage usergroups)
  internal
  view
  returns(Params memory p, string _error)
  {
    if (!(_title.length <= 256)) { _error = "title must be less than 256 bytes."; return; }
    p.title = _title;

    p.usergroup_id = uint32(_params[0]);
    if (!(p.usergroup_id == 0 || usergroups.hasMemberBefore(msg.sender, p.usergroup_id, uint32(now)))) { _error = "you are not in this usergroup."; return; }

    p.options_num = uint32(_params[0] >> 32);
    if (!(p.options_num >= 2)) { _error = "option count must be at least 2."; return; }

    p.select_min = uint32(_params[0] >> 2*32);
    p.select_max = uint32(_params[0] >> 3*32);
    if (!(p.select_min >= 1 && p.select_max <= p.options_num && p.select_min <= p.select_max)) { _error = "select option count must be between 1 and option count."; return; }

    p.start_time = uint32(_params[0] >> 4*32);
    p.end_time = uint32(_params[0] >> 5*32);
    if (!(p.start_time >= now - 120)) { _error = "start time must be greater than now minus 20 minutes."; return; }
    if (!(p.end_time > p.start_time && p.end_time >= now)) { _error = "end time must be greater than now and start_time."; return; }

    p.allow_multi_winner = uint32(_params[1]);

    p.n_min_total_votes = uint32(_params[1] >> 32);
    p.d_min_total_votes = uint32(_params[1] >> 2*32);
    if (!(p.d_min_total_votes > 0 && (p.d_min_total_votes == 1 || p.n_min_total_votes <= p.d_min_total_votes))) { _error = "min_total_votes error."; return; }
    if (!(p.usergroup_id > 0 || p.d_min_total_votes == 1)) { _error = "for public voting, min_total_votes error."; return; }

    p.n_min_winner_votes = uint32(_params[1] >> 3*32);
    p.d_min_winner_votes = uint32(_params[1] >> 4*32);
    if (!(p.d_min_winner_votes > 0 && (p.d_min_winner_votes == 1 || p.n_min_winner_votes <= p.d_min_winner_votes))) { _error = "min_winner_votes error."; return; }
  }

  /**
    * @dev publishVoting and publishVotingSlice is used for publishing a voting.
    *
    *  content of a voting is title/description/options etc.
    *  content can be large if image or file is included, so slice strategy is applied. length of a slice better be multiple of 32 bytes.
    *  content can be the digest of voting content, e.g. a hash value and title, the complete content could be stored at other server.
    *
    * @param self voting manager
    * @param _meta right to left per uint32, [0]: nonce, [1]: client nonce, [2]: number of slices, [3]: index of this slice
    * @param _slice a slice of content
    * @param _params parameters detailed below, each bytes32 from right to left per uint32
    *  _params[0]: [0]: usergroup_id (0 means public) [1]: options_num, [2]: select_min, [3]: select_max, [4]: start_time, [5]: end_time
    *  _params[1]: [0]: allow_multi_winner, [1]: numerator of min_total_votes, [2]: denominator of min_total_votes, [3]: numerator of min_winner_votes, [4]: denominator of min_winner_votes
    * @param usergroups usergroup manager
    * @return _voting_id incremental id in this voting system. After all slices are published, non zero is returned, otherwise zero is returned.
    *
    * NOTE: this function consumes gas, defining as internal to inline bytecode into contract
    */
  function publishVoting(Manager storage self, bytes32 _meta, bytes _slice, bytes32[2] _params, bytes _title, Usergroup.Manager storage usergroups)
  internal
  {
    Params memory params;
    string memory error;
    (params, error) = parseParams(_params, _title, usergroups);
    require(bytes(error).length == 0, error);

    Record storage voting = storeVotingSlice(self, _meta, _slice);
    voting.params = params;

    doPublishVoting(self, usergroups);
  }

  /**
    * @dev publishVoting and publishVotingSlice is used for publishing a voting.
    *
    *  content of a voting is title/description/options etc.
    *  content can be large if image or file is included, so slice strategy is applied. length of a slice better be multiple of 32 bytes.
    *  content can be the digest of voting content, e.g. a hash value and title, the complete content could be stored at other server.
    *
    * @param self voting manager
    * @param _meta right to left per uint32, [0]: nonce, [1]: client nonce, [2]: number of slices, [3]: index of this slice
    * @param _slice a slice of content
    *
    * NOTE: this function consumes gas, defining as internal to inline bytecode into contract
    */
  function publishVotingSlice(Manager storage self, bytes32 _meta, bytes _slice, Usergroup.Manager storage usergroups)
  internal
  {
    storeVotingSlice(self, _meta, _slice);
    doPublishVoting(self, usergroups);
  }

  function storeVotingSlice(Manager storage self, bytes32 _meta, bytes _slice)
  internal
  returns(Record storage voting)
  {
    PublishingRecord storage tmp = self.votingIPublishing[msg.sender];

    uint32 nonce = uint32(_meta);
    uint32 client_nonce = uint32(_meta >> 32);
    uint32 slices_num = uint32(_meta >> 2*32);
    uint32 slice_index = uint32(_meta >> 3*32);
    bool is_new_voting = (nonce == tmp.nonce + 1);

    require(is_new_voting || nonce == tmp.nonce, "nonce error.");
    require(is_new_voting || (client_nonce != 0 && client_nonce == tmp.client_nonce), "cliennt nonce error.");
    require((is_new_voting || slices_num == tmp.slices_num) && slices_num >= 1, "number of slices error.");
    require(slice_index >= 0 && slice_index < slices_num, "index of slice error.");

    if (tmp.voting_id == 0) {
      if (self.votings.length == 0) {
        self.votings.length = 1;
      }

      tmp.voting_id = uint32(self.votings.length);
      self.votings.length++;
    }

    voting = self.votings[tmp.voting_id];

    if (is_new_voting) {
      tmp.nonce = nonce;
      tmp.client_nonce = client_nonce;
      tmp.slices_num = slices_num;
      tmp.got_slices = new bytes(slices_num);
      voting.content = new bytes[](slices_num);
    }

    tmp.got_slices[slice_index] = byte(1);
    voting.content[slice_index] = _slice;
  }

  function doPublishVoting(Manager storage self, Usergroup.Manager storage usergroups)
  internal
  {
    PublishingRecord storage tmp = self.votingIPublishing[msg.sender];

    uint32 i = 0;

    for (i = 0; i < tmp.slices_num; i++) {
      if (tmp.got_slices[i] == 0) {
        // not get all slices
        return;
      }
    }

    // got all slices, publish voting

    Record storage voting = self.votings[tmp.voting_id];
    voting.params.owner = msg.sender;
    voting.params.create_time = uint32(now);
    voting.params.id = tmp.voting_id;
    voting.params.voters_max = voting.params.usergroup_id == 0 ? 0 : usergroups.membersNumBefore(voting.params.usergroup_id, uint32(now));
    voting.params.votes_max = voting.params.voters_max; // no weight now
    voting.votes.length = 1;
    voting.result.options = new uint32[](voting.params.options_num);

    self.votingsIPublished[msg.sender].push(tmp.voting_id);

    if (voting.params.usergroup_id == 0) {
      self.votingsInPublic.push(tmp.voting_id);
    } else {
      Usergroup.Member[] storage members = usergroups.usergroups[voting.params.usergroup_id].members;
      uint32 len = uint32(members.length);
      for (i = 1; i < len; i++) {
        self.votingsInUsergroup[members[i].addr].push(tmp.voting_id);
      }
    }

    tmp.voting_id = 0;
    tmp.nonce++;

    emit PublishVoting(tmp.nonce, tmp.client_nonce, voting.params.id, voting.params.title);
  }

  /**
    * @return _total total number of votings
    * @return _voting_ids ids sorted by reverse add order 
    */
  function getVotings(Manager storage self, VotingCategory _category, uint32 _page, uint32 _pagesize)
  public
  view
  returns(uint32 _total, uint32[] _voting_ids)
  {
    _page = _page < 1 ? 1 : _page;
    _pagesize = _pagesize < 1 ? 10 : _pagesize;

    uint32[] storage indices =
      (_category == VotingCategory.IPublished) ? self.votingsIPublished[msg.sender] : (
      (_category == VotingCategory.IVoted) ? self.votingsIVoted[msg.sender] : (
      (_category == VotingCategory.IWatching) ? self.votingsIWatching[msg.sender] : (
      (_category == VotingCategory.InUsergroup) ? self.votingsInUsergroup[msg.sender] : (
      (_category == VotingCategory.InPublic) ? self.votingsInPublic : self.votingsNone
      ))));

    _total = uint32(indices.length);

    uint32 page_start = (_page - 1) * _pagesize;
    uint32 page_end = (_page * _pagesize) < _total ? (_page * _pagesize) : _total;
    uint32 page_len = page_end > page_start ? page_end - page_start : 0;

    _voting_ids = new uint32[](page_len);

    for (uint32 i = 0; i < page_len; i++) {
      _voting_ids[i] = indices[_total - 1 - page_start - i];
    }
  }

  /**
    * @dev get basic info of a voting
    *
    * @param _id id of a voting
    *
    * @return _title title of this voting
    *
    * @return _options_mix detailed below, each bytes32 from right to left per uint32
    *  _options_mix[i]: [0]: option_votes_num, [1]: i_voted, [2]: is_winner
    *
    * @return _mixes detailed below, each bytes32 from right to left per uint32
    *  _mixes[0]: address of owner
    *  _mixes[1]: [0]: usergroup_id (0 means public) [1]: my_vote_time, [2]: select_min, [3]: select_max, [4]: start_time, [5]: end_time, [6]: create_time, [7]: id 
    *  _mixes[2]: [0]: allow_multi_winner, [1]: numerator of min_total_votes, [2]: denominator of min_total_votes, [3]: numerator of min_winner_votes, [4]: denominator of min_winner_votes, [5]: votes_num, [6]: winners_num, [7]: options_num
    *  _mixes[3]: [0]: eth_time (now)
    */
  function getVotingMix(Manager storage self, uint32 _id)
  public
  view
  returns(bytes _title, bytes32[] _options_mix, bytes32[4] _mixes)
  {
    require(_id > 0 && _id < self.votings.length, 'voting id invalid');

    Params memory p = self.votings[_id].params;
    Result memory r = self.votings[_id].result;

    // _title

    _title = p.title;

    // _options_mix

    _options_mix = new bytes32[](p.options_num);

    uint32 my_vote_index = self.votings[_id].votes_index[msg.sender];
    Vote memory my_vote = self.votings[_id].votes[my_vote_index];

    uint32 i;
    uint32 winners_num;
    uint32 max_votes_num;

    if (now > p.end_time) {
      if ((p.d_min_total_votes == 1 && r.votes_num < p.n_min_total_votes)
       || (p.d_min_total_votes > 1 && uint(r.votes_num) * uint(p.d_min_total_votes) < uint(p.votes_max) * uint(p.n_min_total_votes))
      ) {
        winners_num = 0;
      } else {
        for (i = 0; i < p.options_num; i++) {
          if (r.options[i] > max_votes_num) {
            max_votes_num = r.options[i];
            winners_num = 1;
          } else if (r.options[i] == max_votes_num) {
            winners_num++;
          }
        }

        if ((winners_num > 1 && p.allow_multi_winner == 0)
         || (p.d_min_winner_votes == 1 && max_votes_num < p.n_min_winner_votes)
         || (p.d_min_winner_votes > 1 && uint(max_votes_num) * uint(p.d_min_winner_votes) < uint(r.votes_num) * uint(p.n_min_winner_votes))
        ) {
          winners_num = 0;
        }
      }
    }

    uint32 i_voted;
    uint j;

    for (i = 0; i < p.options_num; i++) {
      i_voted = 0;

      for (j = 0; j < my_vote.options.length; j++) {
        if (my_vote.options[j] == i) {
          i_voted = 1;
        }
      }

      _options_mix[i] = bytes32(
        (uint(r.options[i])) |
        (uint(i_voted) << 32) |
        (uint((winners_num > 0 && r.options[i] == max_votes_num) ? 1 : 0) << 2*32)
      );
    }

    // _mixes

    _mixes[0] = bytes32(p.owner);
    _mixes[1] = bytes32(
      (uint(p.usergroup_id)) |
      (uint(my_vote.vote_time) << 32) |
      (uint(p.select_min) << 2*32) |
      (uint(p.select_max) << 3*32) |
      (uint(p.start_time) << 4*32) |
      (uint(p.end_time) << 5*32) |
      (uint(p.create_time) << 6*32) |
      (uint(p.id) << 7*32)
    );
    _mixes[2] = bytes32(
      (uint(p.allow_multi_winner)) |
      (uint(p.n_min_total_votes) << 32) |
      (uint(p.d_min_total_votes) << 2*32) |
      (uint(p.n_min_winner_votes) << 3*32) |
      (uint(p.d_min_winner_votes) << 4*32) |
      (uint(r.votes_num) << 5*32) |
      (uint(winners_num) << 6*32) |
      (uint(p.options_num) << 7*32)
    );
    _mixes[3] = bytes32(now);
  }

  /**
    * @dev client should concat these slices
    */
  function getVotingSlice(Manager storage self, uint32 _voting_id, uint32 _slice_index_in)
  public
  view
  returns(uint32 _slices_num, uint32 _slice_index, bytes _slice)
  {
    Record memory voting = self.votings[_voting_id];

    _slices_num = uint32(voting.content.length);
    _slice_index = _slice_index_in;
    _slice = voting.content[_slice_index_in];
  }

  function validateVote(Manager storage self, uint32 _voting_id, uint32[] _option_ids, Usergroup.Manager storage usergroups)
  public
  view
  returns(string _error)
  {
    Record storage voting = self.votings[_voting_id];

    if (voting.params.usergroup_id > 0 && !usergroups.hasMemberBefore(msg.sender, voting.params.usergroup_id, voting.params.create_time)) {
      return "you are not permitted to vote.";
    }

    if (now > voting.params.end_time) {
      return "voting has ended.";
    }

    if (now < voting.params.start_time) {
      return "voting has not started.";
    }

    if (voting.votes_index[msg.sender] > 0) {
      return "you have voted.";
    }

    for (uint32 i = 0; i < _option_ids.length; i++) {
      if (_option_ids[i] >= voting.params.options_num) {
        return "vote option index error";
      }
    }
  }

  function vote(Manager storage self, uint32 _voting_id, uint32[] _option_ids, Usergroup.Manager storage usergroups)
  public
  {
    string memory _error = validateVote(self, _voting_id, _option_ids, usergroups);
    require(bytes(_error).length == 0, _error);

    Record storage voting = self.votings[_voting_id];
    bool[] memory _options = new bool[](voting.params.options_num);

    uint32 i = 0;
    uint32 n = 0;

    for (i = 0; i < _option_ids.length; i++) {
      if (!_options[_option_ids[i]]) {
        _options[_option_ids[i]] = true;
        n++;
      }
    }

    Vote memory v = Vote({
      voter: msg.sender,
      options: new uint32[](n),
      vote_time: uint32(now)
    });

    uint32 j = 0;

    for (i = 0; i < voting.params.options_num; i++) {
      if (_options[i]) {
        voting.result.options[i]++; // no weight now
        v.options[j] = i;
        j++;
      }
    }

    voting.votes_index[msg.sender] = uint32(voting.votes.length);
    voting.votes.push(v);

    voting.result.voters_num++;
    voting.result.votes_num++; // no weight now

    self.votingsIVoted[msg.sender].push(_voting_id);
  }
}
